import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import com.bc.jexp.Term;
import com.bc.jexp.impl.DefaultNamespace;
import com.bc.jexp.impl.ParserImpl;

public class LoadJar{
	public LoadJar(){  
	}
	public static void main(String[] args) throws IOException{
		LoadJar jar = new LoadJar();  
		try{	      
	    	Class c = Class.forName("com.bc.jexp.impl.ParserImpl");
	    	/*
	    	Class c = Class.forName("com.bc.jexp.Term");
	    	Method m[] = c.getMethods();
	    	for (int i = 0; i < m.length; i++) {
	    		//System.out.println("name = " + m[i].getName());
	    	}
	    	Class[] partypes = new Class[3];   
	    	partypes[0] = Integer.TYPE;    
	    	partypes[1] = Term.class;    
	    	partypes[2] = Term.class;    
	    	Method meth = c.getMethod("Add", partypes);
	    	meth.setAccessible(true);
	    	Constructor ct = c.getConstructor();
	    	Object methobj = ct.newInstance();
	        Object arglist[] = new Object[3];
	        arglist[0] = new Integer(0);
	        arglist[1] = new Term.ConstI(1);
	        arglist[2] = new Term.ConstI(2);
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);
	
	        //Term.Add(Term.TYPE_I, arglist[1],arglist[1]);
	
	    	
	    	*/
	    	Class partypes = String.class;
	        Method meth = c.getMethod("parse", partypes);
	        Object methobj = c.newInstance();
	        Object arglist[] = new Object[1];
	        arglist[0] = "1+2";
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);
	        Term term = new Term.Add(Term.TYPE_I,
                    new Term.ConstI(1),
                    new Term.ConstI(3));
	        term.evalI(null);
	        //Integer retval = (Integer) retobj;
	        //System.out.println(retval.intValue());
	    	
	    	//System.out.println(c.toString());
	    	

	    	//String filename = "D:/KZOOM/workspace/JarTest/src/jexp.jar";
	    	//JarFile jarfile = new JarFile(filename);
	    	//ZipEntry s = jarfile.getEntry("ParserImpl.class");
	    	//Enumeration em = jarfile.entries();
	    	//for (;em.hasMoreElements();) {
	    	//	System.out.println(em.nextElement());
	    	//}
	    } catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	  
} 

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import com.bc.jexp.Term;
import com.bc.jexp.impl.DefaultNamespace;
import com.bc.jexp.impl.ParserImpl;

public class LoadJar{
	public LoadJar(){  
	}
	public static void main(String[] args) throws IOException{
		LoadJar jar = new LoadJar();  
		try{
			Term term = new Term.Add(Term.TYPE_D,
                    new Term.ConstD(1.2),
                    new Term.ConstD(2.8));
			
	    	Class c = Class.forName("com.bc.jexp.Term");
	    	Method m[] = c.getMethods();
	    	for (int i = 0; i < m.length; i++) {
	    		//System.out.println("name = " + m[i].getName());
	    	}
	    	Class[] partypes = new Class[3];   
	    	partypes[0] = Integer.class;    
	    	partypes[1] = Term.class;    
	    	partypes[2] = Term.class;    
	    	Method meth = c.getMethod("Add", partypes);
	    	meth.setAccessible(true);
	    	Constructor ct = c.getConstructor();
	    	Object methobj = ct.newInstance();
	        Object arglist[] = new Object[3];
	        arglist[0] = new Integer(0);
	        arglist[1] = new Term.ConstI(1);
	        arglist[2] = new Term.ConstI(2);
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);

	    	//c.Add(arglist);
	        //Term.Add(Term.TYPE_I, arglist[1],arglist[1]);
	
	        /*    
	    	Class c = Class.forName("com.bc.jexp.impl.ParserImpl");
	    	Class partypes = String.class;
	        Method meth = c.getMethod("parse", partypes);
	        Object methobj = c.newInstance();
	        Object arglist[] = new Object[1];
	        arglist[0] = "1+2";
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);
	        Term term = new Term.Add(Term.TYPE_I,
                    new Term.ConstI(1),
                    new Term.ConstI(3));
	        term.evalI(null);
	    	*/
	        //Integer retval = (Integer) retobj;
	        //System.out.println(retval.intValue());
	    	
	    	//System.out.println(c.toString());
	    	

	    	//String filename = "D:/KZOOM/workspace/JarTest/src/jexp.jar";
	    	//JarFile jarfile = new JarFile(filename);
	    	//ZipEntry s = jarfile.getEntry("ParserImpl.class");
	    	//Enumeration em = jarfile.entries();
	    	//for (;em.hasMoreElements();) {
	    	//	System.out.println(em.nextElement());
	    	//}
	    } catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	  
} Apr 22 00:30
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.aspectj.runtime.CFlow;

import com.bc.jexp.Term;
import com.bc.jexp.impl.DefaultNamespace;
import com.bc.jexp.impl.ParserImpl;

public class LoadJar{
	public LoadJar(){  
	}
	public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException{
		LoadJar jar = new LoadJar();  
		try{
			Term term = new Term.Add(Term.TYPE_D,
                    new Term.ConstD(1.2),
                    new Term.ConstD(2.8));
			
	    	Class c = Class.forName("org.aspectj.runtime.CFlow");
	    	Method m[] = c.getMethods();
	    	for (int i = 0; i < m.length; i++) {
	    		System.out.println("name = " + m[i].getName());
	    	}
	    	Method meth = c.getMethod("getAspect",null);
	    	System.out.println(meth.toString());
	    	Object methobj = c.newInstance();
	    	CFlow cf = new CFlow();
	    	cf.getAspect();
	    	/*
	    	Class[] partypes = new Class[3];   
	    	partypes[0] = Integer.class;    
	    	partypes[1] = Term.class;    
	    	partypes[2] = Term.class;    
	    	Method meth = c.getMethod("Add", partypes);
	    	meth.setAccessible(true);
	    	Constructor ct = c.getConstructor();
	    	Object methobj = ct.newInstance();
	        Object arglist[] = new Object[3];
	        arglist[0] = new Integer(0);
	        arglist[1] = new Term.ConstI(1);
	        arglist[2] = new Term.ConstI(2);
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);
*/
	    	//c.Add(arglist);
	        //Term.Add(Term.TYPE_I, arglist[1],arglist[1]);
	
	        /*    
	    	Class c = Class.forName("com.bc.jexp.impl.ParserImpl");
	    	Class partypes = String.class;
	        Method meth = c.getMethod("parse", partypes);
	        Object methobj = c.newInstance();
	        Object arglist[] = new Object[1];
	        arglist[0] = "1+2";
	        Object retobj = meth.invoke(methobj, arglist);
	        System.out.println(retobj);
	        Term term = new Term.Add(Term.TYPE_I,
                    new Term.ConstI(1),
                    new Term.ConstI(3));
	        term.evalI(null);
	    	*/
	        //Integer retval = (Integer) retobj;
	        //System.out.println(retval.intValue());
	    	
	    	//System.out.println(c.toString());
	    	

	    	//String filename = "D:/KZOOM/workspace/JarTest/src/jexp.jar";
	    	//JarFile jarfile = new JarFile(filename);
	    	//ZipEntry s = jarfile.getEntry("ParserImpl.class");
	    	//Enumeration em = jarfile.entries();
	    	//for (;em.hasMoreElements();) {
	    	//	System.out.println(em.nextElement());
	    	//}
	    } catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	  
} Apr 22 15:30


import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.aspectj.runtime.CFlow;
import org.aspectj.runtime.internal.CFlowStack;

import com.bc.jexp.EvalException;
import com.bc.jexp.ParseException;
import com.bc.jexp.Symbol;
import com.bc.jexp.Term;
import com.bc.jexp.impl.AbstractFunction;
import com.bc.jexp.impl.DefaultNamespace;
import com.bc.jexp.impl.NamespaceImpl;
import com.bc.jexp.impl.ParserImpl;
import com.bc.jexp.impl.Tokenizer;
import com.bc.jexp.impl.SymbolFactory;
import com.bc.jexp.Variable;
import com.bc.jexp.impl.UserFunction;
import com.bc.jexp.EvalEnv;

public class LoadJar{
	public LoadJar(){  
	}
	public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException{
		String[] className = {"com.bc.jexp.impl.ParserImpl"};
		for (int i = 0; i < className.length;i++){
			loadClass(className[i]);
		}
	}
	
	public static void loadClass(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException{
		try{
			String DriverName = "Driver_" + className;
			String javaFileContent =
					"import java.io.IOException;\n"
					+ "import " + className + ";\n"
				   	+ "\npublic class " + DriverName + " {\n"
				    + "	public" + DriverName + "(){}\n"
				    + "	public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException{\n"
				    + "		" + className + " newDriver = new " + className + "();\n"
				    + "		newDriver.";
			
			Class c = Class.forName(className);
			Method methlist[] = c.getDeclaredMethods();
			String methodName = "";
			String methodParameters = "";
			
            for (int i = 0; i < methlist.length;i++){
	        	Method m = methlist[i];
	        	methodName = m.getName();
	        	DriverName += "_" + methodName;
	        	String tempjavaFileContent = javaFileContent + methodName;
	        	String paraValue = "";
	        	boolean generateFlag = true;
	            Class param[] = m.getParameterTypes();
            	if(param.length == 0){
            		break;
            	}
	            for (int j = 0; j < param.length; j++){
	            	String[] paraSplit = param[j].toString().split(" ");
	            	DriverName += "_" +paraSplit[1];
	            	System.out.println(paraSplit[1]);
	            	
	            	Class p = Class.forName(paraSplit[1]);
					//p.newInstance();
					if(p  ==  Integer.class || p == Short.class || p == Long.class){
						paraValue = "1";
					}
					else if(p == Character.class || p == String.class){
						paraValue = "'1'";
					}
					else if(p == Boolean.class ){
						paraValue = "true";
					}
					else if(p == Float.class || p == Double.class){
						paraValue = "1.0";
					}
					else{
						paraValue = "1";
					}
					/*
	            	if(param[j].newInstance()  instanceof  Integer || param[j].newInstance()  instanceof  Short ||param[j].newInstance()  instanceof  Long){
	            		paraValue = "1";
	            	}
	            	else if(param[j].newInstance()  instanceof  Character || param[j].newInstance()  instanceof  String){
	            		paraValue = "'1'";
	            	}
	            	else if(param[j].newInstance() instanceof Boolean ){
	            		paraValue = "true";
	            	}
	            	else if(param[j].newInstance()  instanceof  Float || param[j].newInstance()  instanceof  Double){
	            		paraValue = "1.0";
	            	}
	            	else{
	            		paraValue = param[j].newInstance().toString();
	            	}
	            	*/
	            	if(j == 0){
	            		methodParameters = "(sym";
	            		tempjavaFileContent += "(" + paraValue;
	            		if(j == param.length - 1){
	            			methodParameters += ")";
	            			tempjavaFileContent += ")";
	            		}
	            	}
	            	else if(j == param.length - 1){
	            		methodParameters += "#sym)";
	            		tempjavaFileContent += "," + paraValue + ");";
	            	}
	            	else{
	            		methodParameters += "#sym";
	            		tempjavaFileContent += "," + paraValue;
	            	}
	            }
	            if(!generateFlag)
	            	break;
	            tempjavaFileContent += "\n	}\n}";
	            generateJavaFile(DriverName, tempjavaFileContent);
	            generatePropertiesFile(DriverName, methodName, methodParameters);
            }
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		}
	}
	
	public static void generateJavaFile(String javaFile, String fileContent) throws IOException{
		FileOutputStream out = new FileOutputStream(javaFile + ".java");
		out.write(fileContent.getBytes());
		out.close();
		System.out.println("File generated: " + javaFile + ".java");
	}
	
	public static void generatePropertiesFile(String className, String method, String methodParameters) throws IOException{
		FileOutputStream out = new FileOutputStream(className + ".properties" );
		String propertiesText = 
			"vm.insn_factory.class = gov.nasa.jpf.symbc.SymbolicInstructionFactory\n"
			+ "jpf.listener = gov.nasa.jpf.symbc.SymbolicListener\n"
			+ "vm.classpath = .:./jexp.jar\n"
			+ "vm.sourcepath+= ,${user.home}/tmp\n"
			+ "vm.storage.class=\n"
			+ "symbolic.method=" + method + methodParameters + "\n"
			+ "search.multiple_errors=true\n"
			+ "+vm.peer.packages=gov.nasa.jpf.symbc,gov.nasa.jpf.jvm\n"
			+ "log.level=warning\n"
			+ "jpf.report.console.finished=\n"
			+ className;
		out.write(propertiesText.getBytes());
		out.close();
		System.out.println("File generated: " + className + ".properties");
	}
	
	/*
	public static void invokeCompiler(File javafile) throws IOException{
		String[] cmd = { _compiler, "-classpath", _classpath, javafile.getName()};
		//compile
		Process process = Runtime.getRuntime().exec(cmd);
		try	{ //wait the compiler to end
		   process.waitFor();
		}
		catch (InterruptedException e){
		}
		int val = process.exitValue();
		if (val != 0){
		   throw new RuntimeException("compile error:" + "error code" + val);
		}
	}
	*/

} 